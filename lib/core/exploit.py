import os
import glob
import importlib
from concurrent.futures import ThreadPoolExecutor, as_completed

from lib.core.data import vulnscan_paths


class exploit:
    def __init__(self, urls, pocs, threads):
        self.urls = urls
        self.pocs = pocs
        self.threads = threads
        self.result = []

    def call_check(self, script, url):
        check_func = getattr(script, 'check')
        result = check_func(url)
        if result:
            if type(result) == str:
                self.result.append(result)
            else:
                self.result.extend(result)

    def run(self):
        scripts = []

        # 导入poc
        for poc in self.pocs:
            scripts_name = []
            path = os.path.join(
                vulnscan_paths['vulnscan_plugins_path'], poc, '*.py')
            scripts_path = glob.glob(path)
            for _ in scripts_path:
                script_name = os.path.basename(_).replace('.py', '')
                scripts_name.append(script_name)

            for _ in scripts_name:
                m = importlib.import_module(f'plugins.{poc}.{_}')
                scripts.append(m)

        # 线程池
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            vulns = {executor.submit(self.call_check, s, u) for u in self.urls for s in scripts}
            for future in as_completed(vulns, timeout=3):
                res = future.result()
            
        
            
        print(self.result)

